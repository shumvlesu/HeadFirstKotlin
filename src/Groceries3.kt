fun main() {

    val groceries = listOf(
        Grocery("Tomatoes", "Vegetable", "lb", 3.0, 3),
        Grocery("Mushrooms", "Vegetable", "lb", 4.0, 1),
        Grocery("Bagels", "Bakery", "Pack", 1.5, 2),
        Grocery("Olive oil", "Pantry", "Bottle", 6.0, 1),
        Grocery("Ice cream", "Frozen", "Pack", 3.0, 2)
    )

    //Группировка
    //группируем по категории, получая при этом map. у которой ключ это категория, а значение это List с отобранными продуктами.
    groceries.groupBy { it.category }.forEach {
        println(it.key)
        it.value.forEach { println("    ${it.name}") }
    }
    //Vegetable
    //    Tomatoes
    //    Mushrooms
    //Bakery
    //    Bagels
    //Pantry
    //    Olive oil
    //Frozen
    //    Ice cream


    //fold. есть еще аналог - reduce, там не нужно указывать первый параметр, за первый возьмется первый элемент в коллекции.
    //С функцией fold вы можете задать исходное значение и выполнить некоторую операцию для каждого элемента коллекции.
    // Например, с ее помощью можно перемножить все элементы List<Int> и вернуть результат или же выполнить конкатенацию значений name всех
    //элементов из List<Grocery>
    //здесь мы суммируем все элементы ints. Без цикла, одной строкой, мы перебрали все элементы List.
    val ints = listOf(1, 2, 3)
    val sumOfInts = ints.fold(0) { runningSum, item -> runningSum + item }
    println("sumOfInts: $sumOfInts")
    //sumOfInts: 6

    val productOfInts = ints.fold(1) { runningProduct, item -> runningProduct * item }
    println("productOfInts: $productOfInts")
    //productOfInts: 6

    //Конкатенируем в одну строку все названия
    val names = groceries.fold("") { string, item -> string + " ${item.name}" }
    println("names: $names")
    //names:  Tomatoes Mushrooms Bagels Olive oil Ice cream

    //Узнаем какой остаток после покупок останется от 50р.
    val changeFrom50 = groceries.fold(50.0) { change, item ->
        change - item.unitPrice * item.quantity
    }
    println("changeFrom50: $changeFrom50")
    //changeFrom50: 22.0

}


//* Функции minBy и maxBy используются для определения наименьшего или наибольшего значения в коллекции.
// Каждая из этих функций получает один параметр — лямбдавыражение, тело которого задает критерии функции.
// Возвращаемый тип соответствует типу элементов коллекции.

//*  Функции sumBy или sumByDouble для возвращения суммы элементов коллекции.
//Лямбда выражение, передаваемое в параметре, определяет суммируемую величину.
// Если суммируются данные типа Int, используйте функцию sumBy, а для данных типа Double — функцию sumByDouble.

//*  Функция filter выполняет поиск (фильтрацию) коллекции по заданному критерию.
// Этот критерий задается лямбда выражением, тело которого должно возвращать Boolean.
// filter обычно возвращает List. При использовании этой функции с Map возвращается Map.

//*  Функция map преобразует элементы коллекции по критерию, определяемому лямбда выражением. Она возвращает список List.

//*  Функция forEach работает по принципу цикла for. Она позволяет выполнить одну или несколько операций для каждого элемента коллекции.

//*  Функция groupBy используется для разбиения коллекции на группы.
// Она получает один параметр — лямбда выражение, которое определяет, как должны группироваться элементы.
// Функция возвращает карту Map, у которой ключи определяются критерием лямбда выражения, а каждое значение представлено списком List.

//*  Функция fold позволяет задать исходное значение и выполнить некоторую операцию с каждым элементом коллекции.
// Она получает два параметра: исходное значение и лямбда выражение, определяющее выполняемую операцию.