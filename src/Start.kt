fun main() {

    val r1 = Recipe("Thai Curry",  "Chicken")
    val r2 = Recipe(title = "Thai Curry", mainIngredient = "Chicken")
    val r3 = r1.copy(title = "Chicken Bhuna")
    println("r1 hash code: ${r1.hashCode()}")
    println("r2 hash code: ${r2.hashCode()}")
    println("r3 hash code: ${r3.hashCode()}")
    println("r1 toString: ${r1.toString()}")
    println("r1 == r2? ${r1 == r2}")
    println("r1 === r2? ${r1 === r2}")
    println("r1 == r3? ${r1 == r3}")
    //Разбираем новые свойства Recipe при деструктуризации r1.
    val (title, mainIngredient, vegetarian, difficulty) = r1

    println("title is $title and vegetarian is $vegetarian")

    //Создание объекта Mushroom вызовом первичного конструктора.
    val m1 = Mushroom(6, false)
    println("m1 size is ${m1.size} and isMagic is ${m1.isMagic}")

    //Создание объекта Mushroom вызовом вторичного конструктора.
    val m2 = Mushroom(true)

    println("m2 size is ${m2.size} and isMagic is ${m2.isMagic}")

    //Вызов Int-версии addNumbers.
    println(addNumbers(2, 5))
    //Вызов Double-версии addNumbers
    println(addNumbers(1.6, 7.3))


    //Правила для классов данных
    //* Первичный конструктор обязателен.
    //* Первичный конструктор должен определять один или несколько параметров.
    //* Каждый параметр должен быть помечен как val или var.
    //*Классы данных не должны быть открытыми или абстрактными.


    //* Поведение оператора == определяется реализацией функции equals.

    //*  Каждый класс наследует функции equals, hashCode и toString от класса Any, потому
    //что каждый класс является подклассом Any. Эти функции могут переопределяться.

    //*  Функция equals проверяет, считаются ли два объекта «равными». По умолчанию она возвращает
    //true, если используется для сравнения ссылок на один объект, или false, если сравниваются два
    //разных объекта.

    //*  Оператор === проверяет, ссылаются ли две переменные на один и тот же объект, независимо от типа объекта.

    //*  Класс данных позволяет создавать объекты, предназначенные для хранения данных. Он автоматически переопределяет функции equals,
    //hashCode и toString и включает функции copy и componentN.

    //*  Функция equals классов данных проверяет равенство, сравнивая значения свойств объектов. Если
    //два объекта данных содержат одни и те же данные функция equals возвращает true.

    //*  Функция copy создает новую копию объекта данных с изменением некоторых из свойств. Исходный объект
    //остается неизменным.

    //*  Функции componentN деструктуризируют объекты данных, разбивая их на значения отдельных свойств.

    //*  Класс данных генерирует свои функции с учетом только тех свойств, которые были определены в его
    //первичном конструкторе.

    //*  Конструкторы и функции могут иметь значения параметров по умолчанию. При вызове конструктора или
    //функции значения параметров могут передаваться по порядку объявления или с использованием именованных аргументов.

    //*  Классы могут иметь вторичные конструкторы.

    //*  Перегруженная функция имеет такое же имя, как и существующая. Перегруженная функция должна
    //иметь другие аргументы; кроме того, она может иметь другой возвращаемый тип.

}

